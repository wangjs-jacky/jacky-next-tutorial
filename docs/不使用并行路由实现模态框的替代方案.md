# 不使用并行路由实现模态框的替代方案

> 探索在不使用 Next.js 并行路由的情况下实现模态框效果的各种方法

## 前言

虽然并行路由 + 拦截路由是 Next.js 推荐的实现模态框的方式，但确实有其他方法可以实现类似的效果。本文将介绍几种替代方案，每种方案都有其优缺点。

## 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **并行路由 + 拦截路由** | URL 同步、SEO 友好、刷新保持状态 | 需要理解并行路由概念 | 推荐用于生产环境 |
| **客户端状态 + URL 参数** | 简单易懂、无需并行路由 | URL 不美观、刷新会丢失状态 | 简单场景 |
| **客户端状态管理** | 完全控制、灵活 | 无 URL 同步、刷新丢失 | 临时模态框 |
| **条件渲染** | 简单直接 | 无 URL 同步 | 简单交互 |
| **第三方库** | 功能完整 | 额外依赖 | 复杂需求 |

## 方案 1：客户端状态 + URL 查询参数

### 实现原理

使用 URL 查询参数（如 `?photo=1`）来控制模态框的显示，通过客户端状态管理模态框内容。

### 代码示例

```typescript
"use client";

import { useRouter, useSearchParams } from "next/navigation";
import { useState } from "react";

export default function PhotosPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const photoId = searchParams.get("photo");
  
  // 根据 photoId 查找照片
  const selectedPhoto = photos.find(p => p.id === photoId);

  const openModal = (id: string) => {
    router.push(`/photos?photo=${id}`, { scroll: false });
  };

  const closeModal = () => {
    router.push("/photos", { scroll: false });
  };

  return (
    <>
      {/* 照片列表 */}
      <div className="grid">
        {photos.map(photo => (
          <button onClick={() => openModal(photo.id)}>
            {photo.title}
          </button>
        ))}
      </div>

      {/* 模态框 */}
      {selectedPhoto && (
        <div className="fixed inset-0 z-50" onClick={closeModal}>
          <div onClick={(e) => e.stopPropagation()}>
            {/* 模态框内容 */}
          </div>
        </div>
      )}
    </>
  );
}
```

### 优点

- ✅ 简单易懂，不需要并行路由
- ✅ URL 会更新（虽然不美观）
- ✅ 可以分享链接（带查询参数）

### 缺点

- ❌ URL 不美观：`/photos?photo=1` 而不是 `/photos/1`
- ❌ 刷新页面会丢失状态（取决于实现）
- ❌ 需要手动管理 URL 状态

### 完整示例

参考：`app/photos-alternative/page.tsx`

## 方案 2：纯客户端状态管理

### 实现原理

完全不使用 URL，只使用 React 状态管理模态框的显示和内容。

### 代码示例

```typescript
"use client";

import { useState } from "react";

export default function PhotosPage() {
  const [selectedPhoto, setSelectedPhoto] = useState<Photo | null>(null);

  const openModal = (photo: Photo) => {
    setSelectedPhoto(photo);
  };

  const closeModal = () => {
    setSelectedPhoto(null);
  };

  return (
    <>
      {/* 照片列表 */}
      <div className="grid">
        {photos.map(photo => (
          <button onClick={() => openModal(photo)}>
            {photo.title}
          </button>
        ))}
      </div>

      {/* 模态框 */}
      {selectedPhoto && (
        <div className="fixed inset-0 z-50" onClick={closeModal}>
          <div onClick={(e) => e.stopPropagation()}>
            {/* 模态框内容 */}
          </div>
        </div>
      )}
    </>
  );
}
```

### 优点

- ✅ 最简单，不需要任何路由概念
- ✅ 完全控制，灵活性高
- ✅ 性能好，无路由跳转

### 缺点

- ❌ URL 不会更新
- ❌ 无法分享链接
- ❌ 刷新页面会丢失状态
- ❌ 浏览器前进/后退不工作

### 适用场景

- 临时提示
- 确认对话框
- 不需要 URL 同步的模态框

## 方案 3：使用 Context API

### 实现原理

使用 React Context 全局管理模态框状态，可以在任何组件中打开/关闭模态框。

### 代码示例

```typescript
// contexts/ModalContext.tsx
"use client";

import { createContext, useContext, useState, ReactNode } from "react";

interface ModalContextType {
  openModal: (content: ReactNode) => void;
  closeModal: () => void;
  isOpen: boolean;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export function ModalProvider({ children }: { children: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);
  const [content, setContent] = useState<ReactNode>(null);

  const openModal = (content: ReactNode) => {
    setContent(content);
    setIsOpen(true);
  };

  const closeModal = () => {
    setIsOpen(false);
    setContent(null);
  };

  return (
    <ModalContext.Provider value={{ openModal, closeModal, isOpen }}>
      {children}
      {isOpen && (
        <div className="fixed inset-0 z-50" onClick={closeModal}>
          <div onClick={(e) => e.stopPropagation()}>
            {content}
          </div>
        </div>
      )}
    </ModalContext.Provider>
  );
}

export function useModal() {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error("useModal must be used within ModalProvider");
  }
  return context;
}
```

### 使用方式

```typescript
// app/photos/page.tsx
"use client";

import { useModal } from "@/contexts/ModalContext";

export default function PhotosPage() {
  const { openModal } = useModal();

  return (
    <div>
      {photos.map(photo => (
        <button onClick={() => openModal(<PhotoDetail photo={photo} />)}>
          {photo.title}
        </button>
      ))}
    </div>
  );
}
```

### 优点

- ✅ 全局可用，任何组件都能打开模态框
- ✅ 统一管理，代码组织好
- ✅ 可以嵌套多个模态框

### 缺点

- ❌ 无 URL 同步
- ❌ 需要额外的 Context 设置

## 方案 4：使用第三方库

### 推荐库

#### 1. next-modal

```bash
npm install next-modal
```

```typescript
import { Modal } from "next-modal";

export default function Page() {
  return (
    <Modal>
      <button>打开模态框</button>
    </Modal>
  );
}
```

#### 2. @radix-ui/react-dialog

```bash
npm install @radix-ui/react-dialog
```

```typescript
import * as Dialog from "@radix-ui/react-dialog";

export default function Page() {
  return (
    <Dialog.Root>
      <Dialog.Trigger>打开</Dialog.Trigger>
      <Dialog.Portal>
        <Dialog.Overlay />
        <Dialog.Content>
          {/* 内容 */}
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
}
```

### 优点

- ✅ 功能完整，经过测试
- ✅ 可访问性支持好
- ✅ 文档完善

### 缺点

- ❌ 额外依赖
- ❌ 可能不符合项目需求
- ❌ 学习成本

## 方案 5：使用路由但不用并行路由

### 实现原理

创建独立的模态框路由，通过编程式导航控制显示。

### 代码示例

```typescript
// app/photos/page.tsx
"use client";

import { useRouter } from "next/navigation";

export default function PhotosPage() {
  const router = useRouter();

  return (
    <div>
      {photos.map(photo => (
        <button onClick={() => router.push(`/photos/${photo.id}/modal`)}>
          {photo.title}
        </button>
      ))}
    </div>
  );
}
```

```typescript
// app/photos/[id]/modal/page.tsx
"use client";

import { useRouter } from "next/navigation";

export default function PhotoModal({ params }: { params: { id: string } }) {
  const router = useRouter();

  return (
    <div className="fixed inset-0 z-50" onClick={() => router.back()}>
      <div onClick={(e) => e.stopPropagation()}>
        {/* 模态框内容 */}
      </div>
    </div>
  );
}
```

### 优点

- ✅ URL 同步：`/photos/1/modal`
- ✅ 可以分享链接
- ✅ 刷新保持状态

### 缺点

- ❌ URL 不美观（有 `/modal` 后缀）
- ❌ 需要额外的路由结构
- ❌ 不如拦截路由优雅

## 方案对比总结

### 推荐使用场景

| 场景 | 推荐方案 |
|------|---------|
| **生产环境，需要 SEO** | 并行路由 + 拦截路由 |
| **简单项目，快速原型** | 客户端状态 + URL 参数 |
| **临时提示，不需要 URL** | 纯客户端状态 |
| **全局模态框系统** | Context API |
| **复杂交互，需要库支持** | 第三方库（Radix UI） |

### 关键区别

#### 并行路由 + 拦截路由

```
URL: /photos/1
- 从列表页点击 → 显示模态框（拦截路由）
- 直接访问 → 显示完整页面
- 刷新 → 显示完整页面
```

#### 客户端状态 + URL 参数

```
URL: /photos?photo=1
- 从列表页点击 → 显示模态框
- 直接访问 → 显示列表（需要额外处理）
- 刷新 → 可能丢失状态
```

#### 纯客户端状态

```
URL: /photos
- 从列表页点击 → 显示模态框
- 直接访问 → 显示列表
- 刷新 → 丢失状态
```

## 实际项目建议

### 1. 如果项目简单

使用**方案 1（客户端状态 + URL 参数）**：
- 实现简单
- 不需要理解并行路由
- 适合快速开发

### 2. 如果项目复杂

使用**并行路由 + 拦截路由**：
- Next.js 官方推荐
- URL 同步好
- SEO 友好
- 用户体验最佳

### 3. 如果只是临时模态框

使用**方案 2（纯客户端状态）**：
- 最简单
- 不需要 URL 同步
- 适合确认对话框等

## 总结

**不使用并行路由也可以实现模态框效果**，有多种替代方案：

1. ✅ **客户端状态 + URL 参数**：简单实用
2. ✅ **纯客户端状态**：最简单
3. ✅ **Context API**：全局管理
4. ✅ **第三方库**：功能完整
5. ✅ **独立路由**：URL 同步但不够优雅

**但是**，并行路由 + 拦截路由仍然是 Next.js 推荐的方案，因为：
- URL 同步完美
- SEO 友好
- 刷新保持状态
- 用户体验最佳

选择哪种方案取决于你的具体需求和项目复杂度。

## 参考

- [Next.js 并行路由文档](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)
- [Next.js 拦截路由文档](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes)
- [Radix UI Dialog](https://www.radix-ui.com/primitives/docs/components/dialog)

